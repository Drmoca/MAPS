---
title: "Meeting: 9-4-15"
output: html_document
---

```{r, echo=FALSE}
library(expm)
```

When you were away, spent much of my time thinking about how to make the computation faster. Tried many different things and finally came up with a much simpler (and faster) solution.

## A much simplified approximation

Let $T_{i,j}$ denote the coalescent time of a lineage sampled from lineage $i$ and lineage $j$. Then,

$$P(T_{i,j} = t) = \sum_{k=1}^{g} q_k (e^{R^0t})_{(i,j), (k,k)}$$

which can be shown by taking the limit of $\Delta t \to 0$. $R^0$ is the instantaneous rate matrix of the coalescent process for a sample size of two. 

For intuition, imagine in the rate matrix, the coalescent rates are zero then
$$ (e^{R^0t})_{(i,j), (k,k)} = (e^{Mt})_{(i,k)} (e^{Mt})_{(j,k)}$$ 
where $M$ is the migration rate matrix such that $M_{i,j}$ is the migration rate from deme $i$ to deme $j$ for $i \neq j$ and $M_{i,i} = -\sum_{k, k \neq i} M_{i,k}$. This is true because coalescent events are what requires you to model both lineages jointly. If the coalescent rates are zero, then both lineages are independent of each other.

Now, imagine that coalescent rates are much smaller than the migration rates so that $R^0_{i,i}$ is dominated by the migration rates, then numerically, the above approximation will still be a good one. Intuitively, this is like restricting coalescent events until time $t$, this works so well because the probability of a coalescent event before $t$ is rare -- especially if $t$ is small.

Here, are some numerical experiments to show that this approximation is indeed very accurate.

```{r, echo = FALSE}
library(expm)
#source("myImagePlot.R")

makeQ <- function(M, q){
  Q = matrix(nrow=5, ncol=5, 0)
  # STATES:
  # (1,1), (1,2), (2,1), (2,2), C
  Q[1,2] = M[1,2]
  Q[1,3] = M[1,2]
  Q[1,5] = q[1]
  
  Q[2,1] = M[2,1]
  Q[2,4] = M[1,2]
  
  Q[3,1] = M[2,1]
  Q[3,4] = M[1,2]
  
  Q[4,2] = M[2,1]
  Q[4,3] = M[2,1]
  Q[4,5] = q[2]
  diag(Q) = -rowSums(Q)
  return(Q)
}


t = 10
m = c(0.0488609, 0.0488609)
#N = c(10300, 20004)
#q = 1/(2*N)
q = c(0.000934978, 0.00099386)
M = matrix(nrow = 2, ncol =2, 0)
M[1,2] = m[1]
M[2,1] = m[2]
M = M
Q = makeQ(M,q)
Q = Q[-5,]
Q = Q[,-5]
P = expm(Q*t)


diag(M) = -rowSums(M)
Papprox = expm(M*t)

paste0("coalescent rate: ", q)
paste0("migration rate: ", m)
paste0("time: ", t, " generations")


# Probability that starting out in deme 1 and deme 1
paste0("approximation is ", Papprox[1,1]*Papprox[1,1], ", exact: ", P[1,1])

# Probability that starting out in deme 1 and deme 2
paste0("approximation is ", Papprox[1,1]*Papprox[2,2], ", exact: ", P[2,2])

# Probability that starting out in deme 2 and deme 2
paste0("approximation is ", Papprox[2,2]*Papprox[2,2], ", exact: ", P[4,4])


```

Then, I use eigendecomposition to re-write $M = PDP^T$. Then, $e^{Mt} = Pe^{Dt}P^T$ ($P^{-1} = P^T$ because $M$ is symmetric). A strength of this is that computing the integral (using Gaussian quadrature) $\int p(T_{i,j} = t) g(t) dt$ only requires one eigen decomposition and then I can use the above identity for computing $p(T_{i,j} = t)$. However, the drawback is that eigendecomposition is $O(n^3)$. 

## MCMC implementation

I played with different implementations of priors but I ended up using almost the exact same implementation as Desi. Except that now qMuRate is nonzero and free to vary. I plotted the prior with the logl = -1 and was able to recapture my prior.

## eems2 run on POPRES data

I ran it on a subset of the POPRES data just to test the MCMC and to invesitage the fit of the model to the data. It seems to work:

Here is the observed versus fitted IBD population similarity matrix (nDemes = 32) for niter = 100k:
```
OBSERVED:
0.012446 0.008786 0.008516 0.007199 0.006981 0.004478
0.008786 0.029349 0.007990 0.065642 0.004639 0.005028
0.008516 0.007990 0.011354 0.017248 0.005460 0.005546
0.007199 0.065642 0.017248 0.107062 0.006812 0.008462
0.006981 0.004639 0.005460 0.006812 0.067658 0.022676
0.004478 0.005028 0.005546 0.008462 0.022676 0.041145

EXPECTED (niter = ?):
0.012658 0.007223 0.009438 0.007003 0.003932 0.005146
0.007223 0.030569 0.012972 0.053650 0.006697 0.005381
0.009438 0.012972 0.010551 0.016741 0.005503 0.005999
0.007003 0.053650 0.016741 0.140718 0.007894 0.005267
0.003932 0.006697 0.005503 0.007894 0.063544 0.024275
0.005146 0.005381 0.005999 0.005267 0.024275 0.040449

EXPECTED (niter = ?)
0.012847 0.007439 0.009602 0.007312 0.004397 0.005766
0.007439 0.029678 0.012170 0.053759 0.006643 0.004963
0.009602 0.012170 0.009778 0.015990 0.005822 0.006234
0.007312 0.053759 0.015990 0.147403 0.008718 0.005095
0.004397 0.006643 0.005822 0.008718 0.065464 0.026100
0.005766 0.004963 0.006234 0.005095 0.026100 0.040457

EXPECTED (niter = ?)
0.012432 0.007571 0.009306 0.007611 0.003693 0.004504
0.007571 0.029129 0.012156 0.052344 0.006427 0.004564
0.009306 0.012156 0.009290 0.016146 0.005047 0.004853
0.007611 0.052344 0.016146 0.140562 0.008735 0.005049
0.003693 0.006427 0.005047 0.008735 0.059431 0.019152
0.004504 0.004564 0.004853 0.005049 0.019152 0.020739

EXPECTED (niter = 100k):
0.009764 0.005381 0.007596 0.004827 0.003682 0.004518
0.005381 0.030414 0.009225 0.056337 0.005324 0.003646
0.007596 0.009225 0.007673 0.011379 0.004348 0.004565
0.004827 0.056337 0.011379 0.165792 0.007031 0.003739
0.003682 0.005324 0.004348 0.007031 0.083923 0.029280
0.004518 0.003646 0.004565 0.003739 0.029280 0.045752
```

The updating in the MCMC chain could use improving (PLOT THESE)

Ending iteration 99049 with acceptance proportions:

	(10303/12475) = 82.59% for type "qTileRate"

	(6599/12394) = 53.24% for type "qTileMove"

	(348/12403) = 2.81% for type "qBirthDeath"

	(2093/12471) = 16.78% for type "qMeanRate"

	(3152/12233) = 25.77% for type "mTileRate"

	(5487/12448) = 44.08% for type "mTileMove"

	(951/12219) = 7.78% for type "mBirthDeath"

	(1208/12406) = 9.74% for type "mMeanRate"

	(0/0) = nan% for type "d.f."

 and effective degrees of freedom = 962.00

  number of qVoronoi tiles = 11

  number of mVoronoi tiles = 4

  Log prior = -4.66

  Log llike = -47923.86

Here is the coalescence rate of each deme:

  deme = 0, q rate = 0.000000
  
  deme = 1, q rate = 0.000000
  
  deme = 2, q rate = 0.000000
  
  deme = 3, q rate = 0.000091
  
  deme = 4, q rate = 0.000037
  
  deme = 5, q rate = 0.000060
  
  deme = 6, q rate = 0.000005
  
  deme = 7, q rate = 0.000000
  
  deme = 8, q rate = 0.000001
  
  deme = 9, q rate = 0.000091
  
  deme = 10, q rate = 0.000000
  
  deme = 11, q rate = 0.000000
  
  deme = 12, q rate = 0.000001
  
  deme = 13, q rate = 0.000000
  
  deme = 14, q rate = 0.000001
  
  deme = 15, q rate = 0.000031
  
  deme = 16, q rate = 0.000000
  
  deme = 17, q rate = 0.000001
  
  deme = 18, q rate = 0.000001
  
  deme = 19, q rate = 0.000031
  
  deme = 20, q rate = 0.000001
  
  deme = 21, q rate = 0.000001
  
  deme = 22, q rate = 0.000888
  
  deme = 23, q rate = 0.000888

Here is the migration rate of each edge, edges as pairs of demes
  edge = (6,5), m rate = 0.038609
  
  edge = (6,4), m rate = 0.025260
  
  edge = (4,5), m rate = 0.025260
  
  edge = (4,8), m rate = 0.011911
  
  edge = (4,7), m rate = 0.011911
  
  edge = (7,8), m rate = 0.011911
  
  edge = (7,1), m rate = 0.011911
  
  edge = (7,3), m rate = 0.026650
  
  edge = (3,1), m rate = 0.026650
  
  edge = (3,9), m rate = 0.041389
  
  edge = (5,10), m rate = 0.038609
  
  edge = (5,11), m rate = 0.038609
  
  edge = (5,8), m rate = 0.025260
  
  edge = (8,11), m rate = 0.025260
  
  edge = (8,2), m rate = 0.011911
  
  edge = (8,1), m rate = 0.011911
  
  edge = (1,2), m rate = 0.011911
  
  edge = (1,12), m rate = 0.026650
  
  edge = (1,9), m rate = 0.026650
  
  edge = (9,12), m rate = 0.041389
  
  edge = (10,13), m rate = 0.038609
  
  edge = (10,11), m rate = 0.038609
  
  edge = (11,13), m rate = 0.038609
  
  edge = (11,0), m rate = 0.038609
  
  edge = (11,2), m rate = 0.025260
  
  edge = (2,0), m rate = 0.025260
  
  edge = (2,14), m rate = 0.026650
  
  edge = (2,12), m rate = 0.026650
  
  edge = (12,14), m rate = 0.041389
  
  edge = (12,15), m rate = 0.041389
  
  edge = (13,16), m rate = 0.028233
  
  edge = (13,17), m rate = 0.028233
  
  edge = (13,0), m rate = 0.038609
  
  edge = (0,17), m rate = 0.028233
  
  edge = (0,18), m rate = 0.028233
  
  edge = (0,14), m rate = 0.039999
  
  edge = (14,18), m rate = 0.029623
  
  edge = (14,19), m rate = 0.041389
  
  edge = (14,15), m rate = 0.041389
  
  edge = (15,19), m rate = 0.041389
  
  edge = (16,20), m rate = 0.017856
  
  edge = (16,17), m rate = 0.017856
  
  edge = (17,20), m rate = 0.017856
  
  edge = (17,21), m rate = 0.017856
  
  edge = (17,18), m rate = 0.017856
  
  edge = (18,21), m rate = 0.017856
  
  edge = (18,22), m rate = 0.017856
  
  edge = (18,19), m rate = 0.029623
  
  edge = (19,22), m rate = 0.029623
  
  edge = (19,23), m rate = 0.029623
  
  edge = (20,21), m rate = 0.017856
  
  edge = (21,22), m rate = 0.017856
  
  edge = (22,23), m rate = 0.017856

![migration rates - POPRES](../test/data/plots-mrates01-ndemes=80.png)
![coalescent rates - POPRES](../test/data/plots-qrates01-ndemes=80.png)

## Uniform grid

Constant population size and migration rates throughout the grid. Using IBD segments greater than 2cM.

![Uniform migration rates (> 2cM)](../test/data/3x4_uniform/plot-mrates01.png)

## barrier simulation

Barrier in the middle (10 generations ago) and constant population size throughout. Using IBD segments greater than 6cM.

![Barrier in the middle (> 6cM)](../test/data/3x4_barrier/plot-mrates01.png)

See if you can see the barrier in the real data and a barrier that is long ago. 
