---
title: "Finding realistic parameters to simulate under"
output: html_document
---
```{r, echo=FALSE}
library(expm)
```
## finding suitable parameters.
IBD softwares are finicky to fine tuning parameters. To make sure our fine tuning parameters are fine tuned to realistic data, we must first infer realistic parameters to simulate under. In this first section, we focus on inferring realistic parameters for a simple two deme model.


## empirical data from POPRES

Here's we'll use the POPRES data to fit a two deme model between UK and Italy to find suitable parameters.

```{r, echo=FALSE, cache=TRUE}
library(data.table)
ibd_blocklens = read.csv("data/coop_popres/ibd-blocklens.csv")
ibd_labels = read.csv("data/coop_popres/ibd-pop-info.csv")

# in centimorgan
cutOff = 4

# apply cutoff and do it and need to combine across chromosomes
italy_subjects = ibd_labels$SUBJID[which(ibd_labels$COUNTRY_SELF == "Italy")]
uk_subjects = ibd_labels$SUBJID[which(ibd_labels$COUNTRY_SELF == "United Kingdom")]
 
within_uk = ibd_blocklens[(is.element(ibd_blocklens$id1, uk_subjects) & is.element(ibd_blocklens$id2, uk_subjects)),]
within_uk$maplen[within_uk$maplen < cutOff] = 0
within_uk$maplen[within_uk$maplen >= cutOff] = 1
within_uk = data.table(within_uk)
N = within_uk[, list(maplen = sum(maplen), chrom = sum(chrom)), by = list(id1, id2)]
m_uk = mean(N$maplen)

within_italy = ibd_blocklens[(is.element(ibd_blocklens$id1, italy_subjects) & is.element(ibd_blocklens$id2, italy_subjects)),]
within_italy$maplen[within_italy$maplen < cutOff] = 0
within_italy$maplen[within_italy$maplen >= cutOff] = 1
within_italy = data.table(within_italy)
N = within_italy[, list(maplen = sum(maplen), chrom = sum(chrom)), by = list(id1, id2)]
m_italy = mean(N$maplen)

uk_italy = ibd_blocklens[(is.element(ibd_blocklens$id1, uk_subjects) & is.element(ibd_blocklens$id2, italy_subjects)),]
uk_italy$maplen[uk_italy$maplen < cutOff] = 0
uk_italy$maplen[uk_italy$maplen >= cutOff] = 1
uk_italy = data.table(uk_italy)
N = uk_italy[, list(maplen = sum(maplen), chrom = sum(chrom)), by = list(id1, id2)]
m_uk_italy = mean(N$maplen)
```
The means are for L > `r cutOff` cM: within UK `r m_uk`, within ITALY `r m_italy` and between UK and Italy `r m_uk_italy`

```{r, echo=FALSE}
makeQ <- function(m, q){
  Q = matrix(nrow=4, ncol=4, 0)
  Q[1,2] = 2*m
  Q[1,4] = q[1]
  Q[2,1] = m
  Q[2,3] = m
  Q[3,2] = 2*m
  Q[3,4] = q[2]
  diag(Q) = -rowSums(Q)
  return(Q)
}

computeWeights <- function(L,r){
  u = L*r
  x = c(0.118440697736960550688, 0.3973475034735802657556, 0.8365549141880933313119, 1.437175158191620443607,
        2.200789508440616292336, 3.129448303166859096349, 4.225699164493802071261, 5.492626704368934083587,
        6.933903364122364597039, 8.553853192793023779194, 10.35753137020864105106, 12.35082332811269876439,
        14.54056869943518703492, 16.93471724415800802837, 19.54252664684054185266, 22.37481610233449499411,
        25.44429563058376261798, 28.76600031447167014762, 32.35787326932856805551, 36.24156497875364752439,
        40.44355691460364227197, 44.99678841355200250088, 49.94309754094208987181, 55.33704611950810443499,
        61.25224904369593075136, 67.79260716731075303985, 75.11420274687672563149, 83.47405073153149030595,
        93.36359463048878316735, 106.0462505962874034422)
  w = c(0.02093564741472521761, 0.09585049298017654367, 0.18833296435057945936, 0.23281944819987904471,
        0.2060782293528492151, 0.138528960450616358, 0.07293919110208096649, 0.030605607903988887905,
        0.010333948458420042431, 0.002821608083735993584, 6.2402663742264620427E-4, 1.1168849922460852198E-4,
        1.6129719270580565631E-5, 1.87044426274856472768E-6, 1.72995513372709914535E-7, 1.26506996496773906645E-8,
        7.2352574135703022224E-10, 3.19320138447436406004E-11, 1.069761647687436460972E-12, 2.66597906070505518515E-14,
        4.82019019925788439097E-16, 6.12740480626441608041E-18, 5.26125812567892365789E-20, 2.89562589607893296815E-22,
        9.51695437836864011982E-25, 1.69046847745875738033E-27, 1.39738002075239812243E-30, 4.20697826929603166432E-34,
        2.89826026866498969507E-38, 1.411587124593531584E-43)
  
  w = w*(1/(L*2*r*L))
  x = x/(2*r*L)
  return(list(w=w, x=x))
}

calculateIntegral <- function(Q, L, r){
  ret = computeWeights(L, r)
  t = ret$x
  w = ret$w
  n = length(t)
  P_within = rep(0, n)
  P_between = rep(0, n)
  for (i in 1:n){
    P_within[i] = expm(Q*t[i])[1,4]
    P_between[i] = expm(Q*t[i])[2,4]
  }
  p_within = c(0, diff(P_within)/(t[2:n]-t[1:(n-1)]))
  int_within = w%*%p_within
  p_between = c(0, diff(P_between)/(t[2:n]-t[1:(n-1)]))
  int_between = w%*%p_between
  return(c(int_within, int_between))
}
euc.dist <- function(x1, x2) sqrt(sum((x1 - x2) ^ 2))

L = cutOff*1e6
genomeSize = 2.9e9
r = 1e-8

fr <- function(par){
  N = rep(0, 2)
  N[1] = par[1]
  N[2] = par[1]
  m = par[2]
  q = 1/(2*N)
  Q = makeQ(m,q)
  Ncnts = genomeSize*calculateIntegral(Q, L, r)
  obs = c((m_italy+m_uk)/2, m_uk_italy)
  analy = c(Ncnts[1], Ncnts[2])
  return(euc.dist(obs, analy))
}
o = optim(c(1000,0.01), fr, lower=c(100, 0), upper=c(10000000, 0.1))
par = o$par
N = c(par[1], par[1])
m = par[2]
q = 1/(2*N)
Q = makeQ(m,q)
analyl = genomeSize*calculateIntegral(Q, L, r)
obs = c((m_italy+m_uk)/2, m_uk_italy)

```

Doing optimization with constraints such that the population sizes of the two demes are equal, we get a good fit with observed: `r obs` and analytical: `r analyl`

The answers is population size is: `r par[1]` and migration rate is: `r par[2]`


Below, I vary the IBD threshold. Interestingly, we see as we increase the threshold the population size gets larger and the migration rate smaller. Encouraginly, this shows that the longer IBD segments are more reflective of recent structure.
```{r, echo=FALSE}
L = c(4e6, 5e6, 6e6, 7e6,8e6)
sharing_italy = c(0.109261, 0.06, 0.035, 0.022, 0.0157)
sharing_uk = c(0.15605, 0.08, 0.036, 0.021, 0.013)
sharing_italy_uk = c(0.037487, 0.0126, 0.00454, 0.0019, 0.000973)
N = c(2.6e4, 3.6e4, 4.9e4, 6.24e4, 7.3e4)
m = c(0.038, 0.0065, 0.005, 0.0019, 0.003)
plot(L, sharing_italy, xlab = "threshold (in cM)", ylab = "mean sharing", col = "red", lwd=2)
points(L, sharing_uk, col = "blue", lwd=2)
points(L, sharing_italy_uk, col ="green", lwd=2)
legend("topright", c("within Italy", "within UK", "Italy-UK"), fill=c("red", "blue", "green"))
plot(L, N, xlab = "threshold (in cM)", ylab = "(2N)")
plot(L, m, xlab = "threshold (in cM)", ylab = "(m)")
```
